{"version":3,"sources":["core/_mixins.scss","blocks/hero.scss","core/_functions.scss"],"names":[],"mappings":"AA6BA;;gFAEgF;ACxBhF;EACE,mBAAkB;EAClB,qBAAa;EAAb,qBAAa;EAAb,cAAa;EACb,6BAAsB;EAAtB,8BAAsB;MAAtB,2BAAsB;UAAtB,uBAAsB;EACtB,2BAAoB;MAApB,wBAAoB;UAApB,qBAAoB;EACpB,yBAAuB;MAAvB,sBAAuB;UAAvB,wBAAuB;EACvB,mBATsB;EAUtB,kBAXiB;CAalB;;AAED;EACE,mBAAkB;EAClB,WAAU;EACV,iBAAgB;EAChB,eAAc;EACd,mBAnBsB;EAoBtB,mBAAkB;CACnB;;AAED;EACE,eAAc;EACd,iBCiIa;EDhIb,mBAAkB;CACnB;;AAED;EACE,cAAa;CACd;;AAED;;EAEE,mBAAkB;EAClB,WAAU;EACV,OAAM;EACN,QAAO;EACP,SAAQ;EACR,UAAS;CACV;;AAED;EACE,qBAAiB;KAAjB,kBAAiB;EACjB,YAAW;EACX,aAAY;CACb","file":"../../blocks/hero.css","sourcesContent":["////\n/// Global mixins passed to all files\n/// @author Sebastian Nitu\n/// @access public\n////\n\n// sass-lint:disable no-empty-rulesets, indentation, no-vendor-prefixes\n\n/// Output a colophone comment for the top of packages\n/// @param {String} $hook\n@mixin add-colophon($hook) {\n/*!\n * #{$project} - #{$description}\n * @version #{$version}\n * @bundle #{$hook}\n *\n * @author #{$author}\n * @repo #{$repo}\n * @url #{$url}\n *\n * Copyright (c) #{$year} Sebastian Nitu (MIT Licensed)\n */\n}\n\n/// Output a comment to flag sections\n/// @param {String} $hook\n/// @param {Boolean} $details - Whether or not to add project name and version\n@mixin add-comment($hook, $details: true) {\n@if ($details) {\n/*==============================================================================\n  @#{$hook} - #{$project} #{$version}\n==============================================================================*/\n} @else {\n/*==============================================================================\n  @#{$hook}\n==============================================================================*/\n}\n}\n\n/// Output a comment to flag sections\n/// @param {String} $hook\n@mixin add-comment-subtle($hook) {\n/**\n * #{$hook}\n */\n}\n\n/// Allows you to apply a clearfix to an element that contains floats.\n@mixin add-clearfix() {\n  &::after {\n    content: '';\n    display: table;\n    clear: both;\n  }\n}\n\n/// Removes the clearfix styles from an element. This is typically used when a\n/// clearfix is inherited on an element and you'd like it removed.\n@mixin remove-clearfix() {\n  &::after {\n    content: none;\n    display: none;\n    clear: none;\n  }\n}\n\n/// Makes touch devices use momentum-based scrolling for the given element.\n@mixin add-scrollable() {\n  overflow-y: scroll;\n  -webkit-overflow-scrolling: touch;\n  transition: top linear 0.2s, bottom linear 0.2s;\n}\n","@import 'vrem-core';\n@include add-comment('hero');\n\n$hero-height: 500px !default;\n$hero-padding: 1em 1.5em !default;\n$hero-background: null !default;\n\n.hero {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n  justify-content: center;\n  padding: $hero-padding;\n  min-height: $hero-height;\n  background: $hero-background;\n}\n\n.hero__container {\n  position: relative;\n  z-index: 2;\n  max-width: 75rem;\n  margin: 0 auto;\n  padding: $hero-padding;\n  text-align: center;\n}\n\n.hero__title {\n  font-size: 2em;\n  font-weight: font-weight('light');\n  margin-bottom: 1em;\n}\n\n.hero__action {\n  margin: 2em 0;\n}\n\n.hero__background,\n.hero__canvas {\n  position: absolute;\n  z-index: 1;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.hero__background {\n  object-fit: cover;\n  width: 100%;\n  height: 100%;\n}\n","////\n/// Global functions passed to all files\n/// @author Sebastian Nitu\n/// @access public\n////\n\n/// jQuery-style extend function for when `map-merge()` isn't enough. Use when\n/// we need to merge more than two maps and/or need a merge to be recursive.\n/// @param {Map} $map - The first map\n/// @param {Map} $maps - Can be a list of maps\n/// @param {Boolean} $deep [false] - Whether or not to enable recursive mode\n/// @return {Map} $map\n@function map-extend($map, $maps.../*, $deep */) {\n  $last: nth($maps, -1);\n  $deep: $last == true;\n  $max: if($deep, length($maps) - 1, length($maps));\n\n  // Loop through all maps in $maps...\n  @for $i from 1 through $max {\n    // Store current map\n    $current: nth($maps, $i);\n\n    // If not in deep mode, simply merge current map with map\n    @if not $deep {\n      $map: map-merge($map, $current);\n    } @else {\n      // If in deep mode, loop through all tuples in current map\n      @each $key, $value in $current {\n\n        // If value is a nested map and same key from map is a nested map as well\n        @if type-of($value) == 'map' and type-of(map-get($map, $key)) == 'map' {\n          // Recursive extend\n          $value: map-extend(map-get($map, $key), $value, true);\n        }\n\n        // Merge current tuple with map\n        $map: map-merge($map, ($key: $value));\n      }\n    }\n  }\n\n  @return $map;\n}\n\n/// An easy way to fetch a deep value in a multi-level map. Works much like\n/// map-get() except that you pass multiple keys as the second variable argument\n/// to go down multiple levels in the nested map.\n/// @param {Map} $map\n/// @param {List} $keys\n/// @return {Map} $map\n@function map-fetch($map, $keys...) {\n  @each $key in $keys {\n    $map: map-get($map, $key);\n  }\n  @return $map;\n}\n\n/// An easy way to set a deep value in a multi-level map. By passing in a map,\n/// value and keys to the original map value you want changed.\n/// @param {Map} $map\n/// @param {Value} $value\n/// @param {List} $keys\n/// @return {Map} $result\n@function map-set($map, $value, $keys) {\n  // sass-lint:disable no-warn\n  $maps: ($map,);\n  $result: null;\n\n  @if type-of(nth($keys, -1)) == 'map' {\n    @warn 'The last key you specified is a map; it will be overrided with `#{$value}`.';\n  }\n\n  @if length($keys) == 1 {\n    @return map-merge($map, ($keys: $value));\n  }\n\n  @for $i from 1 through length($keys) - 1 {\n    $current-key: nth($keys, $i);\n    $current-map: nth($maps, -1);\n    $current-get: map-get($current-map, $current-key);\n    @if $current-get == null {\n      @error 'Key `#{$key}` doesn\\'t exist at current level in map.';\n    }\n    $maps: append($maps, $current-get);\n  }\n\n  @for $i from length($maps) through 1 {\n    $current-map: nth($maps, $i);\n    $current-key: nth($keys, $i);\n    $current-val: if($i == length($maps), $value, $result);\n    $result: map-merge($current-map, ($current-key: $current-val));\n  }\n\n  @return $result;\n}\n\n/// Srtips the unit from a value. e.g. 12px -> 12.\n/// @param {Unit} $val\n/// @return {Value}\n@function strip-units($val) {\n  @return ($val / ($val * 0 + 1));\n}\n\n/// Converts a pixel value to ems.\n/// @param {Pixel} $px\n/// @param {Pixel} $base [$font-size]\n/// @return {Em}\n@function px-to-em($px, $base: $font-size) {\n  @if unitless($px) {\n    $px: 1px * $px;\n  }\n  @if unitless($base) {\n    $base: 1px * $base;\n  }\n  $px: ($px / $base) * 1em;\n  @return strip-units($px) * 1em;\n}\n\n/// Converts a pixel value to rems.\n/// @param {Pixel} $px\n/// @return {Em}\n@function px-to-rem($px) {\n  @if unitless($px) {\n    $px: 1px * $px;\n  }\n  @if unitless($font-size) {\n    $font-size: 1px * $font-size;\n  }\n  $px: ($px / $font-size) * 1rem;\n  @return strip-units($px) * 1rem;\n}\n\n/// Converts an em value to pixels.\n/// @param {Em} $em\n/// @param {Pixel} $base [$font-size]\n/// @return {Pixel}\n@function em-to-px($em, $base: $font-size) {\n  @if unitless($em) {\n    $em: 1em * $em;\n  }\n  @if unitless($base) {\n    $base: 1px * $base;\n  }\n  $em: ($em * $base) / 1px;\n  @return strip-units($em) * 1px;\n}\n\n/// Output the font weight value using the a weight keyword.\n/// @param {String} $weight - Font weight keyword\n/// @return {Number} $value - Font weight value\n@function font-weight($keyword) {\n  $value: null !default;\n\n  @if ($keyword == 'hairline' or $keyword == 'thin') {\n    $value: 100;\n  } @else if ($keyword == 'extra-light') {\n    $value: 200;\n  } @else if ($keyword == 'light') {\n    $value: 300;\n  } @else if ($keyword == 'regular' or $keyword == 'normal') {\n    $value: 400;\n  } @else if ($keyword == 'medium') {\n    $value: 500;\n  } @else if ($keyword == 'semi-bold') {\n    $value: 600;\n  } @else if ($keyword == 'bold') {\n    $value: 700;\n  } @else if ($keyword == 'extra-bold') {\n    $value: 800;\n  } @else if ($keyword == 'black') {\n    $value: 900;\n  }\n\n  @return $value;\n}\n\n/// Returns the aspect ratio in the form of a percentage.\n/// @param {Number} $width\n/// @param {Number} $height\n/// @return {Percent}\n@function aspect-ratio($width, $height) {\n  @return (($height / $width) * 100%);\n}\n"]}