@use "sass:list";
@use "sass:map";
@use "sass:meta";
@use "../utilities/debug-map" as *;

/// Stores all references of custom properties and their meta information.
/// @type map
/// @access private
$_meta: ();

/// Return a value from the usage `$_meta` map.
/// @param {string} $keys...
///   The keys to follow in the `$_meta` map and return its value. Leave empty 
///   to return the entire `$_meta` map.
@function get($keys...) {
  @if (list.length($keys) == 0) {
    @return $_meta;
  } @else {
    @return map.get($_meta, $keys...);
  }
}

/// Set the meta data for a module's property based on the action being taken.
/// @param {string} $module
///   The module name who's custom property is being stored under.
/// @param {string} $prop
///   The custom property name that should be stored.
/// @param {list} $args...
///   The action being taken and any additional flags. Options include:
///   - "ref": The property is being referenced.
///   - "def": The property is being defined.
///   - "override": The property is being overrode.
///   - "required": Required property should be output regardless of usage.
@function set($module, $prop, $args...) {
  @if (map.has-key($_meta, $module, $prop)) {
    $_meta: _update-data($module, $prop, $args...) !global;
  } @else {
    $_meta: map.set($_meta, $module, $prop, _init-data($args...)) !global;
  }
  @return $_meta;
}

/// Mixin alias for running @function `usage.set()`.
@mixin set($module, $prop, $args...) {
  $run: set($module, $prop, $args...);
}

/// Setup initial data for a new property in the usage `$_meta` map. The action
/// parameter will increment the value of that action in the data map.
/// @param {list} $args...
///   The action being taken and any additional flags. Options include:
///   - "ref": The property is being referenced.
///   - "def": The property is being defined.
///   - "override": The property is being overrode.
///   - "required": Required property should be output regardless of usage.
/// @return {map}
///   The initial data map for storing as property value in `$_meta` map.
/// @access private
@function _init-data($args...) {
  $result: ("def": 0, "ref": 0);
  @each $arg in $args {
    // Handle the action
    @if (_is-action($arg)) {
      $result: map.set($result, $arg, 1);
    }
    // Handle the flags
    @else {
      $result: map.set($result, $arg, true);
    }
  }
  @return $result;
}

/// TODO: Documentation
@function _update-data($module, $prop, $args...) {
  $result: $_meta;
  @each $arg in $args {
    // Handle the action
    @if (_is-action($arg)) {
      $n: map.get($result, $module, $prop, $arg) or 0;
      $result: map.set($result, $module, $prop, $arg, $n + 1);
    }
    // Handle the flags
    @else {
      $result: map.set($result, $module, $prop, $arg, true);
    }
  }
  @return $result;
}

/// TODO: Documentation
@function _is-action($value) {
  $actions: "def", "ref", "override";
  @if (list.index($actions, $value)) {
    @return true;
  } @else {
    @return false;
  }
}

/// Remove a property from the usage `$_meta` map.
/// @param {string} $keys...
///   The keys to follow in the `$_meta` map and remove.
@function remove($keys...) {
  $_meta: map.deep-remove($_meta, $keys...) !global;
  @return $_meta;
}

/// Output custom properties based on the provided strategy. This can either be
/// all (via "*" or "all" values) or "used" meaning only the custom properties
/// that have been referenced get output.
/// @param {mixin value} $mixin
///   The mixin to call with params in the output loop. 
///   Value should come from `meta.get-mixin()` usage.
/// @param {string} $module
///   The name of the module being output.
/// @param {map} $moduleMap
///   A map of containing property/value pairs to output.
/// @param {string} $strategy
///   The output strategy to apply. Available options: "*", "all" or "used".
///   - "*" and "all" will output all stored custom properties.
///   - "used" will only output custom properties that have been referenced.
@mixin output($mixin, $module, $moduleMap, $strategy, $args...) {
  
  // If strategy is set to all, output everything in the map.
  @if ($strategy == "*" or $strategy == "all") {
    @each $prop, $value in $moduleMap {
      @if (_meta-check($module, $prop, $args...)) {
        @include meta.apply($mixin, $module, $prop, $value, $args...);
      }
    }
  }
  // Else, only output variable that were referenced.
  @else {
    @each $prop, $value in $moduleMap {
      @if map.has-key($_meta, $module, $prop) {
        @if (_meta-check($module, $prop, $args...)) {
          @include meta.apply($mixin, $module, $prop, $value, $args...);
        }
      }
    }
  }
}

/// TODO: Documentation
@function _meta-check($module, $prop, $flag: null) {
  $meta: get($module, $prop) or ();
  @if ($flag != "override") and (map.has-key($meta, "def")) and (map.get($meta, "def") > 0) {
    @return false;
  } @else {
    @return true;
  }
}

/// Log to console data from the `$_meta` custom properties map. The log can be 
/// filtered using a module name and further with a specific data map to match.
/// @param {string} $module
///   The module name to filter the meta map's data by. Can be set to null, "*"
///   or "all" to return the values of all modules.
/// @param {mao} $filters
///   A filters map containing the values that should match and be returned.
/// 
/// @example scss
///   // Log all properties in the button module that were never referenced.
///   @include usage.log("button", ("ref": 0));
/// 
/// @example scss
///   // Log all properties of every module that are required,
///   @include usage.log("core", ("required": 1));
///
@mixin log($module: null, $filters: ()) {
  @if ($module == "*" or $module == "all") {
    $module: null;
  }
  
  // Initial filtered map is just inherited from meta map.
  $filtered: $_meta;

  // Do a module check and error if one is passed that hasn't been set.
  @if ($module) {
    @if (map.has-key($filtered, $module)) {
      $filtered: map.get($filtered, $module);
    } @else {
      @error "Module map has not been set: \"#{$module}\"";
    }
  }

  // Loop through the provided filters
  @each $filterKey, $filterValue in $filters {
    // If a module was passed.
    @if ($module) {
      @each $prop, $meta in $filtered {
        @if (not map.has-key($meta, $filterKey) or (map.get($meta, $filterKey) != $filterValue)) {
          $filtered: map.remove($filtered, $module, $prop);
        }
      }
    }
    // If a module was not passed.
    @else {
      @each $module, $props in $filtered {
        @each $prop, $meta in $props {
          @if (not map.has-key($meta, $filterKey) or (map.get($meta, $filterKey) != $filterValue)) {
            $filtered: map.deep-remove($filtered, $module, $prop);
            // Remove empty maps if they exist.
            @if (map.get($filtered, $module) == ()) {
              $filtered: map.remove($filtered, $module);
            }
          }
        }
      }
    }
  }

  // Log the filtered map.
  @if ($module) {
    @include debug-map($filtered, "Filtered custom properties of \"#{$module}\"");
  } @else if ($filters != ()) {
    @include debug-map($filtered, "Filtered custom properties");
  } @else {
    @include debug-map($filtered, "All custom properties");
  }
}
