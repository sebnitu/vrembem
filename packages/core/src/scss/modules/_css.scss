@use "sass:list";
@use "sass:map";
@use "sass:meta";
@use "../utilities/debug-map" as *;
@use "../utilities/remove-nth" as *;
@use "../utilities/reverse" as *;
@use "./config";
@use "./usage";

/// The variables map where all custom properties are stored. These are stored
/// under module keys with maps of their custom property key/value pairs.
/// @type map
/// @access private
$-variables: (
  "core": (
    "prefix": config.get("prefix-variables"),
    "prefix-themes": config.get("prefix-themes")
  )
);

/// Function to check whether a module has been set in the `$-variables` map.
/// Will throw an error if the module was not found and is required.
/// @param {string} $module
///   The module to check for its existence.
/// @param {boolean} $required [true]
///   Whether or not the module is required. If set to `true`, will throw an
///   error when it's not found, otherwise will return false.
/// @return {boolean | error}
///   If module exists in map, returns true. Otherwise, will throw error.
/// @access private
@function -module-exists($module, $required: true) {
  @if not map.has-key($-variables, $module) {
    @if $required {
      @error "Module `#{$module}` has not been registered in variables map.";
    } @else {
      @return false;
    }
  } @else {
    @return true;
  }
}

/// Function for setting the prefix on custom properties (CSS variables).
///   - Applies "--" prefix.
///   - Applies "vb-" vrembem prefix.
///   - Applies "[module]" string. Omitted for "core" or "palette" modules.
///   - Result: "--vb-[module]-"
/// @param {string} $module
///   The module name to use as part of the prefix. The "core" and "palette"
///   modules are not prefixed with their module names.
/// @return {string}
///   The custom property prefix string.
/// @access private
@function -prefix($module) {
  @if $module and $module != "core" and $module != "palette" {
    @return "--#{config.get("prefix-variables")}#{$module}-";
  } @else {
    @return "--#{config.get("prefix-variables")}";
  }
}

/// Function to create reference to a custom property using the provided module
/// name, property and optional fallback. Automatically applies the necessary
/// custom property prefix and module name.
/// @param {string} $module
///   The module name to use as part of the prefix. The "core" and "palette"
///   modules are not prefixed with their module names.
/// @param {string} $prop
///   The custom property name to use in the reference.
/// @param {any} $fallback [null]
///   The fallback value to use in the var() declaration.
/// @return {function}
///   Custom property variable reference using var().
///
/// @example scss
///   css.reference("core", "background");
///   // CSS Output
///   var(--vb-background);
///
/// @example scss
///   css.reference("button", "background-hover", "background");
///   // CSS Output
///   var(--vb-button-background-hover, var(--vb-button-background));
///
@function reference($module, $prop, $fallback: null) {
  @if usage.set($module, $prop, "ref") {
    @if $fallback {
      @return var(#{-prefix($module)}#{$prop}, $fallback);
    } @else {
      @return var(#{-prefix($module)}#{$prop});
    }
  }
}

/// Mixin to define custom property using the provided property name and value.
/// Automatically applies with prefix and module name if provided.
/// @param {string} $module
///   The module name to use as part of the prefix. The "core" and "palette"
///   modules are not prefixed with their module names.
/// @param {string} $prop
///   The custom property name to use in the definition.
/// @param {any} $value [null]
///   The value of the custom property.
/// @param {list} $args... ["def"]
///   The action being taken and any additional flags to be passed to
///   `usage.set()`. Defaults to "def".
///
/// @example scss
///   css.define("core", "background", #000);
///   // CSS Output
///   --vb-background: #000;
///
/// @example scss
///   css.define("button", "background", #fff);
///   // CSS Output
///   --vb-button-background: #fff;
///
@mixin define($module, $prop, $value: null, $args...) {
  @if $value {
    // If args is empty, set "def" as the default action.
    @if list.length($args) == 0 {
      $args: "def";
    }

    // Set the usage before outputting the custom property.
    @if usage.set($module, $prop, $args...) {
      // Check if the value has been deferred.
      @if meta.type-of($value) == "list" and list.nth($value, 1) == "defer" {
        // Create the reference using the deferred value list.
        $value: reference(list.nth($value, 2), list.nth($value, 3));
      }

      // Define the custom property.
      #{-prefix($module)}#{$prop}: #{$value};
    }
  }
}

/// Used in place of `set` for when a custom property is dependent on another.
/// This allows the property to be omitted if the original definition is never
/// actually referenced.
/// @param {string} $module
///   The module name to store the custom property under.
/// @param {string | map} $prop
///   The custom property name to store.
@function defer($module, $prop: null) {
  @if not $prop {
    $prop: $module;
    $module: "core";
  }

  @return "defer", $module, $prop;
}

/// Function to return a custom property reference that has been stored in the
/// `$-variables` map using set(). Can also return the entire `$-variables` map
/// or one of the stored module maps.
/// @param {string} $module
///   The module name to get the stored custom property from. Can be omitted if
///   searching a property in the core module.
/// @param {string} $props...
///   The custom property name to return. Can be a list of props for returning
///   var() with fallbacks. Set to "*" to return the entire module map.
/// @return {function | error}
///   Custom property variable reference using var().
///
/// @example scss
///   css.get("background");
///   // CSS Output
///   var(--vb-background);
///
/// @example scss
///   css.get("button", "background");
///   // CSS Output
///   var(--vb-button-background);
///
/// @example scss
///   css.get("button", "background-hover", "background");
///   // CSS Output
///   var(--vb-button-background-hover, var(--vb-button-background));
///
/// @example scss
///   css.get("button", "background-hover", "background", pink);
///   // CSS Output
///   var(--vb-button-background-hover, var(--vb-button-background, pink));
///
@function get($module, $props...) {
  // Return `$-variables` map if module is set to "*" value.
  @if $module == "*" or $module == "all" {
    @return $-variables;
  }

  // Return a nested map in `$-variables` if props contains "*" value.
  @if list.index($props, "*") {
    // Throw error if the module doesn't exist in the map.
    @if -module-exists($module) {
      $props: remove-nth($props, list.index($props, "*"));

      @return map.get($-variables, $module, $props...);
    }
  }

  // If no props are provided, shift the values and set module to "core".
  @if list.length($props) == 0 {
    $props: $module;
    $module: "core";
  }

  // Check if module exists.
  @if -module-exists($module) {
    // Reverse the props list and initialize our result.
    $props: reverse($props);
    $result: null;

    // Get the props count.
    $count: list.length($props);

    // Loop through the props and append them to results as nested fallbacks.
    @for $i from 1 through $count {
      $prop: list.nth($props, $i);
      $value: map.get($-variables, $module, $prop);

      // Check if the value is a deferred property.
      @if meta.type-of($value) == "list" and list.nth($value, 1) == "defer" {
        // Create the reference using the stored value list.
        $ref: reference(list.nth($value, 2), list.nth($value, 3));

        // Update the variables map with the value of the reference.
        $-variables: map.set($-variables, $module, $prop, $ref) !global;

        // Store the reference in our result.
        $result: reference($module, $prop);
      }

      // Check if the property exists in the module or its default theme.
      @else if map.has-key($-variables, $module, $prop) or map.has-key($-variables, $module, config.get("default-theme"), $prop) {
        // store the reference in our result.
        $result: reference($module, $prop, $result);
      }

      // All other cases depend on the property count and its position.
      @else {
        @if $count > 1 and $i == 1 {
          // First prop of the props list, store the raw value as our fallback.
          $result: $prop;
        } @else if $count > 1 {
          // If there are more than one props, reference the undefined variable.
          $result: reference($module, $prop, $result);
        } @else {
          // Else, it should exist in our module map, throw error.
          @error "Property `#{$prop}` does not exist in `#{$module}` variables map.";
        }
      }
    }

    @return $result;
  }
}

/// Mixin to store custom properties for later definition and reference. Can
/// also update the entire `$-variables` map or a stored module map by passing
/// "*" value to `$module` or `$prop` respectively.
/// @param {string} $module
///   The module name to store the custom property under. Set to "*" to replace
///   the entire `$-variables` map with the value of `$prop` (must be a map).
/// @param {string | map} $prop
///   The custom property name to store. Can be a map containing property and
///   value pairs. Values can also contain map of property/value pairs. Set to
///   "*" to merge a module map with the value of `$value` (must be a map).
///   Pass "merge" to `$args` to merge the map, else it is deep-merged.
/// @param {any} $value [null]
///   The custom property value to store. Can be a map containing property and
///   value pairs. Map keys are appended to provided `$prop` parameter.
/// @param {list} $args...
///   The arguments to pass to `usage.set()`. Can be a list containing an action
///   and any additional flags to log for the property.
///
/// @example scss
///   @include css.set("button", "background", #000);
///
///   // Result in `$-variables` map:
///   $-variables: (
///     "button": (
///       "background": #000
///     )
///   );
///
/// @example scss
///   @include css.set("button", (
///     "background": #000,
///     "foreground": #fff,
///   ));
///
///   // Result in `$-variables` map:
///   $-variables: (
///     "button": (
///       "background": #000,
///       "foreground": #fff
///     )
///   );
///
/// @example scss
///   @include css.set("button", (
///     "background": (
///       "hover": #000,
///       "focus": #555,
///       "active": #fff,
///     )
///   ));
///
///   // Result in `$-variables` map:
///   $-variables: (
///     "button": (
///       "background-hover": #000,
///       "background-focus": #555,
///       "background-active": #fff
///     )
///   );
///
@mixin set($module, $prop, $value: null, $args...) {
  // If module is set to "*", update the entire `$-variables` map.
  @if $module == "*" or $module == "all" {
    $-variables: $prop !global;
  }

  // If prop is set to "*", update the module map in `$-variables` map.
  @else if $prop == "*" or $prop == "all" {
    @if list.index($args, "merge") {
      $-variables: map.merge(
        $-variables,
        (
          $module: $value
        )
      ) !global;
    } @else {
      $-variables: map.deep-merge(
        $-variables,
        (
          $module: $value
        )
      ) !global;
    }
  }

  // If the provided prop is a map.
  @else if meta.type-of($prop) == "map" {
    // Add value to args if one exists.
    @if $value {
      $args: list.append($args, $value);
    }

    // Loop through the prop map.
    @each $propKey, $propValue in $prop {
      // Scenario: ("prop": ("prop": "value"))
      @if meta.type-of($propValue) == "map" {
        @each $key, $value in $propValue {
          // Only call `usage.set` if arguments are passed.
          @if list.length($args) > 0 {
            @include usage.set($module, "#{$propKey}-#{$key}", $args...);
          }

          $-variables: map.set($-variables, $module, "#{$propKey}-#{$key}", $value) !global;
        }
      }

      // Scenario: ("prop": "value")
      @else {
        // Only call `usage.set` if arguments are passed.
        @if list.length($args) > 0 {
          @include usage.set($module, $propKey, $args...);
        }

        $-variables: map.set($-variables, $module, $propKey, $propValue) !global;
      }
    }
  }

  // Scenario: "prop", ("prop": "value")
  @else if meta.type-of($value) == "map" {
    @each $key, $value in $value {
      // Only call `usage.set` if arguments are passed.
      @if list.length($args) > 0 {
        @include usage.set($module, "#{$prop}-#{$key}", $args...);
      }

      $-variables: map.set($-variables, $module, "#{$prop}-#{$key}", $value) !global;
    }
  }

  // Scenario: "prop", "value"
  @else {
    // Only call `usage.set` if arguments are passed.
    @if list.length($args) > 0 {
      @include usage.set($module, $prop, $args...);
    }

    $-variables: map.set($-variables, $module, $prop, $value) !global;
  }
}

/// Register a module in the variables map. This is used when a module is needed
/// to be available for later use but without setting any custom properties.
/// @param {string} $module
///   The module to be registered.
@mixin register($module) {
  $-variables: map.set($-variables, $module, "register", true) !global;
}

/// Mixin to remove items from the `$-variables` custom properties map.
/// @param {string} $keys...
///   The list of keys to follow and remove from the custom properties map.
@mixin remove($keys...) {
  @if usage.remove($keys...) {
    $-variables: map.deep-remove($-variables, $keys...) !global;
  }
}

/// Mixin to override a previously defined custom property. This is primarily
/// used in the context of a modifier. Provided module and property must exist
/// in the `$-variables` custom properties map.
/// @param {string} $module
///   The module name to check the custom property under.
/// @param {string | map} $prop
///   The custom property name to override. Can be a map containing property and
///   value pairs
/// @param {any} $value [null]
///   The property value to override with.
///
/// @example scss
///   @include css.override("core", "background", #000);
///
///   // CSS Output
///   --vb-background: #000;
///
/// @example scss
///   @include css.override("button", "background", #fff);
///
///   // CSS Output
///   --vb-button-background: #fff;
///
/// @example scss
///   @include css.override("button", (
///     "background": #000,
///     "foreground": #fff
///   ));
///
///   // CSS Output
///   --vb-button-background: #000;
///   --vb-button-foreground: #fff;
///
@mixin override($module, $prop, $value: null) {
  @if -module-exists($module) {
    @if meta.type-of($prop) == "map" {
      @each $key, $value in $prop {
        @if $value {
          @include define($module, $key, $value, "override");
        }
      }
    } @else {
      @if $value {
        @include define($module, $prop, $value, "override");
      }
    }
  }
}

/// Output all the stored custom properties of a provided module or of all
/// modules. Provided module must exist in the `$-variables` map.
/// @param {string} $module ["*"]
///   The module to output all custom properties from. If no module is passed or
///   set to "*" or "all", will output all custom properties for all modules.
/// @param {string} $strategy ["used"]
///   The output strategy to apply. Available options: "*", "all" or "used".
///   - "*" and "all" will output all stored custom properties.
///   - "used" will only output custom properties that have been referenced.
///
/// @example scss
///   // Example value in `$-variables` map:
///   $-variables: (
///     "button": (
///       "background": #555,
///       "foreground": #fff,
///       "border": 1px solid #000
///     )
///   );
///
///   // SCSS input
///   :root {
///     @include css.output("button");
///   }
///
///   // CSS output
///   :root {
///     --vb-button-background: #555;
///     --vb-button-foreground: #fff;
///     --vb-button-border: 1px solid #000;
///   }
///
@mixin output($module: "*", $strategy: config.get("output-strategy")) {
  @if $module == "*" or $module == "all" {
    // Call output() for every module in $-variables.
    @each $module in map.keys($-variables) {
      @include output($module, $strategy);
    }
  } @else if -module-exists($module, false) {
    $module-map: map.get($-variables, $module);

    // Output custom properties via usage output.
    @include usage.output(meta.get-mixin("define"), $module, $module-map, $strategy);
  }
}

/// Log to console either the entire `$-variables` custom properties map, a
/// module map or module theme. Provided module must exist in the  `$-variables`
/// custom properties map.
/// @param {string} $module ["*"]
///   A module within the custom properties map to log. Leaving as `null` will
///   log the entire map.
@mixin log($module: "*", $props...) {
  @if $module == "*" or $module == "all" {
    @include debug-map($-variables, 'Custom properties of "*"');
  } @else if -module-exists($module) {
    @if list.length($props) > 0 {
      @include debug-map(map.get($-variables, $module, $props...), 'Custom properties of "#{$module}" > "#{$props}"');
    } @else {
      @include debug-map(map.get($-variables, $module), 'Custom properties of "#{$module}"');
    }
  }
}
