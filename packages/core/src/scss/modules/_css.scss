@use "sass:list";
@use "sass:map";
@use "sass:meta";
@use "../utilities/debug-map" as *;
@use "../utilities/empty-map" as *;
@use "../utilities/remove-nth" as *;
@use "../utilities/reverse" as *;
@use "./config";

/// The custom properties map where all custom properties are stored. These are
/// stored under component keys with maps of their custom property.
/// @type map
/// @access private
$-custom-properties: (
  "core": (
    "prefix": config.get("prefix-variables"),
    "prefix-themes": config.get("prefix-themes")
  )
);

/// Function to check whether a component has been registered in the custom
/// properties map. Will throw an error if the component was not found and is
/// required.
///
/// @param {string} $component
///   The component to check for its existence.
///
/// @param {boolean} $required (true)
///   Whether or not the component is required. If set to `true`, will throw an
///   error when it's not found, otherwise will return false.
///
/// @return {boolean|error}
///   If component exists in map, returns true. Otherwise, will throw error.
///
/// @access private
///
@function -component-exists($component, $required: true) {
  @if not map.has-key($-custom-properties, $component) {
    @if $required {
      @error "Component `#{$component}` has not been registered in custom properties map.";
    } @else {
      @return false;
    }
  } @else {
    @return true;
  }
}

/// Function for setting the prefix on custom properties (CSS variables).
///   - Applies "--" prefix.
///   - Applies "vb-" vrembem prefix.
///   - Applies "[component]" string. Omitted for "core" or "palette"
///     components.
///   - Result: "--vb-[component]-"
///
/// @param {string} $component
///   The component name to use as part of the prefix. The "core" and
///   "palette" components are not prefixed with their component names.
///
/// @return {string}
///   The custom property prefix string.
///
/// @access private
///
@function -prefix($component) {
  @if $component and $component != "core" and $component != "palette" {
    @return "--#{config.get("prefix-variables")}#{$component}-";
  } @else {
    @return "--#{config.get("prefix-variables")}";
  }
}

/// Function to check if custom properties map has a specific component
/// property.
///
/// @param {string} $keys...
///   The keys to traverse in the custom properties map.
///
@function has($keys...) {
  @return map.has-key($-custom-properties, $keys...);
}

/// Register a component in the custom properties map. This is used when a
/// component is needed to be available for later use but without setting any
/// custom properties.
///
/// @param {string} $component
///   The component to register.
///
@mixin register($component) {
  $-custom-properties: map.set($-custom-properties, $component, empty-map()) !global;
}

/// Function to create reference to a custom property using the provided
/// component name, property and optional fallback. Automatically applies the
/// necessary custom property prefix and component name.
///
/// @param {string} $component
///   The component name to use as part of the prefix. The "core" and "palette"
///   components are not prefixed with their component names.
/// @param {string} $prop
///   The custom property name to use in the reference.
/// @param {any} $fallback (null)
///   The fallback value to use in the var() declaration.
///
/// @return {function}
///   Custom property variable reference using var().
///
/// @example scss
///   css.reference("core", "background");
///   // CSS Output
///   var(--vb-background);
///
/// @example scss
///   css.reference("button", "background-hover", "background");
///   // CSS Output
///   var(--vb-button-background-hover, var(--vb-button-background));
///
@function reference($component, $prop, $fallback: null) {
  @if $fallback {
    @return var(#{-prefix($component)}#{$prop}, $fallback);
  } @else {
    @return var(#{-prefix($component)}#{$prop});
  }
}

/// Mixin to define custom property using the provided property name and value.
/// Automatically applies with prefix and component name if provided.
///
/// @param {string} $component
///   The component name to use as part of the prefix. The "core" and "palette"
///   components are not prefixed with their component names.
/// @param {string} $prop
///   The custom property name to use in the definition.
/// @param {any} $value (null)
///   The value of the custom property.
///
/// @example scss
///   css.define("core", "background", #000);
///   // CSS Output
///   --vb-background: #000;
///
/// @example scss
///   css.define("button", "background", #fff);
///   // CSS Output
///   --vb-button-background: #fff;
///
@mixin define($component, $prop, $value: null) {
  @if $value and meta.type-of($value) != "map" {
    #{-prefix($component)}#{$prop}: #{$value};
  }
}

/// Function to return a custom property reference that has been stored in the
/// custom properties map using set(). Can also return the entire custom
/// properties map or one of the stored component maps.
///
/// @param {string} $component
///   The component name to get the stored custom property from. Can be omitted
///   if searching a property in the core component.
/// @param {string} $props...
///   The custom property name to return. Can be a list of props for returning
///   var() with fallbacks. Set to "*" to return the entire component map.
///
/// @return {function|error}
///   Custom property variable reference using var().
///
/// @example scss
///   css.get("background");
///   // CSS Output
///   var(--vb-background);
///
/// @example scss
///   css.get("button", "background");
///   // CSS Output
///   var(--vb-button-background);
///
/// @example scss
///   css.get("button", "background-hover", "background");
///   // CSS Output
///   var(--vb-button-background-hover, var(--vb-button-background));
///
/// @example scss
///   css.get("button", "background-hover", "background", pink);
///   // CSS Output
///   var(--vb-button-background-hover, var(--vb-button-background, pink));
///
@function get($component, $props...) {
  // Return custom properties map if component is set to "*" value
  @if $component == "*" or $component == "all" {
    @return $-custom-properties;
  }

  // Return a nested map in custom properties map if props contains "*" value
  @if list.index($props, "*") {
    // Throw error if the component doesn't exist in the map
    @if -component-exists($component) {
      $props: remove-nth($props, list.index($props, "*"));

      @return map.get($-custom-properties, $component, $props...);
    }
  }

  // If no props are provided, shift the values and set component to "core"
  @if list.length($props) == 0 {
    $props: $component;
    $component: "core";
  }

  // Check if component exists
  @if -component-exists($component) {
    // Reverse the props list and initialize our result
    $props: reverse($props);
    $result: null;

    // Get the props count
    $count: list.length($props);

    // Loop through the props and append them to results as nested fallbacks
    @for $i from 1 through $count {
      $prop: list.nth($props, $i);
      $value: map.get($-custom-properties, $component, $prop);

      // Check if the property exists in the component or its default theme
      @if map.has-key($-custom-properties, $component, $prop) or map.has-key($-custom-properties, $component, config.get("default-theme"), $prop) {
        // store the reference in our result
        $result: reference($component, $prop, $result);
      }

      // All other cases depend on the property count and its position
      @else {
        @if $count > 1 and $i == 1 {
          // First prop of the props list, store the raw value as our fallback
          $result: $prop;
        } @else if $count > 1 {
          // If there are more than one props, reference the undefined variable
          $result: reference($component, $prop, $result);
        } @else {
          // Else, it should exist in our component map, throw error
          @error "Property `#{$prop}` does not exist in `#{$component}` custom properties map.";
        }
      }
    }

    @return $result;
  }
}

/// Mixin to store custom properties for later definition and reference. Can
/// also update the entire custom properties map or a stored component map by
/// passing "*" value to `$component` or `$prop` respectively.
///
/// @param {string} $component
///   The component name to store the custom property under. Set to "*" to
///   replace the entire map with the value of `$prop` (must be a map).
/// @param {string|map} $prop
///   The custom property name to store. Can be a map containing property and
///   value pairs. Values can also contain map of property/value pairs. Set to
///   "*" to merge a component map with the value of `$value` (must be a map).
/// @param {any} $value (null)
///   The custom property value to store. Can be a map containing property and
///   value pairs. Map keys are appended to provided `$prop` parameter.
/// @param {boolean} $deep (true)
///   Whether or not to use `merge` or `deep-merge` when combining maps.
///
/// @example scss
///   @include css.set("button", "background", #000);
///
///   // Result in custom properties map:
///   $-custom-properties: (
///     "button": (
///       "background": #000
///     )
///   );
///
/// @example scss
///   @include css.set("button", (
///     "background": #000,
///     "foreground": #fff,
///   ));
///
///   // Result in custom properties map:
///   $-custom-properties: (
///     "button": (
///       "background": #000,
///       "foreground": #fff
///     )
///   );
///
/// @example scss
///   @include css.set("button", (
///     "background": (
///       "hover": #000,
///       "focus": #555,
///       "active": #fff,
///     )
///   ));
///
///   // Result in custom properties map:
///   $-custom-properties: (
///     "button": (
///       "background-hover": #000,
///       "background-focus": #555,
///       "background-active": #fff
///     )
///   );
///
@mixin set($component, $prop, $value: null, $deep: true) {
  // If component is set to "*", update the entire custom properties map
  @if $component == "*" or $component == "all" {
    $-custom-properties: $prop !global;
  }

  // If prop is set to "*", update the component map in custom properties map
  @else if $prop == "*" or $prop == "all" {
    @if $deep != true {
      $-custom-properties: map.merge(
        $-custom-properties,
        (
          $component: $value
        )
      ) !global;
    } @else {
      $-custom-properties: map.deep-merge(
        $-custom-properties,
        (
          $component: $value
        )
      ) !global;
    }
  }

  // If the provided prop is a map
  @else if meta.type-of($prop) == "map" {
    // Loop through the prop map
    @each $propKey, $propValue in $prop {
      // Scenario: ("prop": ("prop": "value"))
      @if meta.type-of($propValue) == "map" {
        @each $key, $value in $propValue {
          $-custom-properties: map.set($-custom-properties, $component, "#{$propKey}-#{$key}", $value) !global;
        }
      }

      // Scenario: ("prop": "value")
      @else {
        $-custom-properties: map.set($-custom-properties, $component, $propKey, $propValue) !global;
      }
    }
  }

  // Scenario: "prop", ("prop": "value")
  @else if meta.type-of($value) == "map" {
    @each $key, $value in $value {
      $-custom-properties: map.set($-custom-properties, $component, "#{$prop}-#{$key}", $value) !global;
    }
  }

  // Scenario: "prop", "value"
  @else {
    $-custom-properties: map.set($-custom-properties, $component, $prop, $value) !global;
  }
}

/// Mixin to remove items from the custom properties map.
///
/// @param {string} $keys...
///   The list of keys to follow and remove from the custom properties map.
///
@mixin remove($keys...) {
  $-custom-properties: map.deep-remove($-custom-properties, $keys...) !global;
}

/// Mixin to override previously defined custom properties. This is primarily
/// used in the context of a modifier. Provided component must exist in the
/// custom properties map.
///
/// @param {string} $component
///   The component to override.
/// @param {string|map} $prop
///   The custom property name to override. Can be a map containing property and
///   value pairs.
/// @param {any} $value (null)
///   The property value to override with.
///
/// @example scss
///   @include css.override("core", "background", #000);
///
///   // CSS Output
///   --vb-background: #000;
///
/// @example scss
///   @include css.override("button", "background", #fff);
///
///   // CSS Output
///   --vb-button-background: #fff;
///
/// @example scss
///   @include css.override("button", (
///     "background": #000,
///     "foreground": #fff
///   ));
///
///   // CSS Output
///   --vb-button-background: #000;
///   --vb-button-foreground: #fff;
///
@mixin override($component, $prop, $value: null) {
  @if -component-exists($component) {
    @if meta.type-of($prop) == "map" {
      @each $key, $value in $prop {
        @if $value {
          @include define($component, $key, $value);
        }
      }
    } @else {
      @if $value {
        @include define($component, $prop, $value);
      }
    }
  }
}

/// Output all custom properties of a provided component. Or output all custom
/// properties from all components by passing "*" as the argument.
///
/// @param {string} $component ("*")
///   The component to output all custom properties from. If no component is
///   passed or set to "*" or "all", will output all custom properties for all
///   components.
///
/// @example scss
///   // Example value in custom properties map:
///   $-custom-properties: (
///     "button": (
///       "background": #555,
///       "foreground": #fff,
///       "border": 1px solid #000
///     )
///   );
///
///   // SCSS input
///   :root {
///     @include css.output("button");
///   }
///
///   // CSS output
///   :root {
///     --vb-button-background: #555;
///     --vb-button-foreground: #fff;
///     --vb-button-border: 1px solid #000;
///   }
///
@mixin output($component: "*") {
  @if $component == "*" or $component == "all" {
    // Call output() for every component in $-custom-properties
    @each $component in map.keys($-custom-properties) {
      @include output($component);
    }
  } @else if -component-exists($component, false) {
    // Get the component's property map
    $property-map: map.get($-custom-properties, $component);

    // Loop through the property map
    @each $prop, $value in $property-map {
      @include define($component, $prop, $value);
    }
  }
}

/// Log to console all custom properties, a component map or component theme.
/// Provided component must be registered in the custom properties map.
///
/// @param {string} $component ("*")
///   A component within the custom properties map to log. Leaving as `null`
///   will log the entire map.
///
@mixin log($component: "*", $props...) {
  @if $component == "*" or $component == "all" {
    @include debug-map($-custom-properties, 'Custom properties of "*"');
  } @else if -component-exists($component) {
    @if list.length($props) > 0 {
      @include debug-map(map.get($-custom-properties, $component, $props...), 'Custom properties of "#{$component}" > "#{$props}"');
    } @else {
      @include debug-map(map.get($-custom-properties, $component), 'Custom properties of "#{$component}"');
    }
  }
}
