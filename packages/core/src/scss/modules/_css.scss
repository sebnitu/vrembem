@use "sass:list";
@use "sass:map";
@use "sass:meta";

@use "../utilities/debug-map" as *;
@use "../utilities/remove-nth" as *;
@use "../utilities/reverse" as *;
@use "./config";
@use "./usage";

/// The variables map where all custom properties are stored. These are stored
/// under module keys with maps of their custom property key/value pairs.
/// @type map
/// @access private
$_variables: (
  "core": (
    "prefix": config.get("prefix-variables")
  )
);

/// Function to check whether a module has been set in the `$_variables` map.
/// Will throw an error if the module was not found and is required.
/// @param {string} $module
///   The module to check for its existence.
/// @param {boolean} $required [true]
///   Whether or not the module is required. If set to `true`, will throw an
///   error when it's not found, otherwise will return false. 
/// @return {boolean | error}
///   If module exists in map, returns true. Otherwise, will throw error.
/// @access private
@function _module-exists($module, $required: true) {
  @if not map.has-key($_variables, $module) {
    @if $required {
      @error "Module `#{$module}` has not been set in variables map.";
    } @else {
      @return false;
    }
  } @else {
    @return true;
  }
}

/// Function for setting the prefix on custom properties (CSS variables).
///   - Applies "--" prefix.
///   - Applies "vb-" vrembem prefix.
///   - Applies "[module]" string. Omitted for "core" or "palette" modules.
///   - Result: "--vb-[module]-"
/// @param {string} $module
///   The module name to use as part of the prefix. The "core" and "palette"
///   modules are not prefixed with their module names.
/// @return {string} 
///   The custom property prefix string.
/// @access private
@function _prefix($module) {
  @if ($module and $module != "core" and $module != "palette") {
    @return "--#{config.get("prefix-variables")}#{$module}-";
  } @else {
    @return "--#{config.get("prefix-variables")}";
  }
}

/// Function to create reference to a custom property using the provided module
/// name, property and optional fallback. Automatically applies the necessary 
/// custom property prefix and module name.
/// @param {string} $module
///   The module name to use as part of the prefix. The "core" and "palette"
///   modules are not prefixed with their module names.
/// @param {string} $prop
///   The custom property name to use in the reference.
/// @param {any} $fallback [null]
///   The fallback value to use in the var() declaration.
/// @return {function} 
///   Custom property variable reference using var().
/// 
/// @example scss
///   css.reference("core", "background");
///   // CSS Output
///   var(--vb-background);
/// 
/// @example scss
///   css.reference("button", "background-hover", "background");
///   // CSS Output
///   var(--vb-button-background-hover, var(--vb-button-background));
///
@function reference($module, $prop, $fallback: null) {
  @if usage.set($module, $prop, "ref") {
    @if ($fallback) {
      @return var(#{_prefix($module)}#{$prop}, $fallback);
    } @else {
      @return var(#{_prefix($module)}#{$prop});
    }
  }
}

/// Mixin to define custom property using the provided property name and value.
/// Automatically applies with prefix and module name if provided.
/// @param {string} $module
///   The module name to use as part of the prefix. The "core" and "palette"
///   modules are not prefixed with their module names.
/// @param {string} $prop
///   The custom property name to use in the definition.
/// @param {any} $value [null]
///   The value of the custom property.
/// @param {list} $args... ["def"]
///   The action being taken and any additional flags to be passed to 
///   `usage.set()`. Defaults to "def".
/// 
/// @example scss
///   css.define("core", "background", #000);
///   // CSS Output
///   --vb-background: #000;
/// 
/// @example scss
///   css.define("button", "background", #fff);
///   // CSS Output
///   --vb-button-background: #fff;
///
@mixin define($module, $prop, $value: null, $args...) {
  @if ($value) {
    // If args is empty, set "def" as the default action.
    @if (list.length($args) == 0) {
      $args: "def";
    }
    // Set the usage before outputting the custom property.
    @if usage.set($module, $prop, $args...) {
      #{_prefix($module)}#{$prop}: #{$value};
    }
  }
}

/// Function to return a custom property reference that has been stored in the 
/// `$_variables` map using set(). Can also return the entire `$_variables` map
/// or one of the stored module maps.
/// @param {string} $module
///   The module name to get the stored custom property from. Can be omitted if
///   searching a property in the core module.
/// @param {string} $props...
///   The custom property name to return. Can be a list of props for returning 
///   var() with fallbacks. Set to "*" to return the entire module map.
/// @return {function | error} 
///   Custom property variable reference using var().
/// 
/// @example scss
///   css.get("background");
///   // CSS Output
///   var(--vb-background);
/// 
/// @example scss
///   css.get("button", "background");
///   // CSS Output
///   var(--vb-button-background);
/// 
/// @example scss
///   css.get("button", "background-hover", "background");
///   // CSS Output
///   var(--vb-button-background-hover, var(--vb-button-background));
/// 
/// @example scss
///   css.get("button", "background-hover", "background", pink);
///   // CSS Output
///   var(--vb-button-background-hover, var(--vb-button-background, pink));
///
@function get($module, $props...) {
  // Return `$_variables` map if module is set to "*" value.
  @if ($module == "*") or ($module == "all") {
    @return $_variables;
  }

  // Return a nested map in `$_variables` if props contains "*" value.
  @if (list.index($props, "*")) {
    // Throw error if the module doesn't exist in the map.
    @if _module-exists($module) {
      $props: remove-nth($props, list.index($props, "*"));
      @return map.get($_variables, $module, $props...);
    }
  }

  // If no props are provided, shift the values and set module to "core".
  @if (list.length($props) == 0) {
    $props: $module;
    $module: "core";
  }

  // Check if module exists.
  @if _module-exists($module) {
    // Reverse the props list and initialize our result.
    $props: reverse($props);
    $result: null;

    // TODO: if it's a single item and not a list, ensure that it exists?
    $count: list.length($props);
    // Loop through the props and append them to results as nested fallbacks.
    @for $i from 1 through $count {
      $prop: list.nth($props, $i);
      // If the property is not the first item in the list or exists in the
      // module or the module's default theme...
      @if 
        map.has-key($_variables, $module, $prop) or
        map.has-key($_variables, $module, config.get("default-theme"), $prop)
      {
        // store the reference in our result.
        $result: reference($module, $prop, $result);
      } @else {
        @if $count > 1 and $i == 1 {
          // First prop of the props list, store the raw value as our fallback.
          $result: $prop;
        } @else if $count > 1 {
          // If there are more than one props, reference the undefined variable.
          $result: reference($module, $prop, $result);
        } @else {
          // Else, it should exist in our module map, throw error.
          @error "Property `#{$prop}` does not exist in `#{$module}` variables map.";
        }
      }
    }
    
    @return $result;
  }
}

/// Mixin to store custom properties for later definition and reference. Can
/// also update the entire `$_variables` map or a stored module map by passing
/// "*" value to `$module` or `$prop` respectively.
/// @param {string} $module
///   The module name to store the custom property under. Set to "*" to replace
///   the entire `$_variables` map with the value of `$prop` (must be a map).
/// @param {string | map} $prop
///   The custom property name to store. Can be a map containing property and 
///   value pairs. Values can also contain map of property/value pairs. Set to 
///   "*" to merge a module map with the value of `$value` (must be a map).
///   Pass "merge" to `$args` to merge the map, else it is deep-merged.
/// @param {any} $value [null]
///   The custom property value to store. Can be a map containing property and 
///   value pairs. Map keys are appended to provided `$prop` parameter.
/// @param {list} $args...
///   The arguments to pass to `usage.set()`. Can be a list containing an action
///   and any additional flags to log for the property.
/// 
/// @example scss
///   @include css.set("button", "background", #000);
/// 
///   // Result in `$_variables` map:
///   $_variables: (
///     "button": (
///       "background": #000
///     )
///   );
/// 
/// @example scss
///   @include css.set("button", (
///     "background": #000,
///     "foreground": #fff,
///   ));
/// 
///   // Result in `$_variables` map:
///   $_variables: (
///     "button": (
///       "background": #000,
///       "foreground": #fff
///     )
///   );
/// 
/// @example scss
///   @include css.set("button", (
///     "background": (
///       "hover": #000,
///       "focus": #555,
///       "active": #fff,
///     )
///   ));
/// 
///   // Result in `$_variables` map:
///   $_variables: (
///     "button": (
///       "background-hover": #000,
///       "background-focus": #555,
///       "background-active": #fff
///     )
///   );
///
@mixin set($module, $prop, $value: null, $args...) {
  // If module is set to "*", update the entire `$_variables` map.
  @if ($module == "*") or ($module == "all") {
    $_variables: $prop !global;
  }

  // If prop is set to "*", update the module map in `$_variables` map.
  @else if ($prop == "*") or ($prop == "all") {
    @if (list.index($args, "merge")) {
      $_variables: map.merge($_variables, ($module: $value)) !global;
    } @else {
      $_variables: map.deep-merge($_variables, ($module: $value)) !global;
    }
  }

  // If the provided prop is a map.
  @else if (meta.type-of($prop) == "map") {
    
    // Add value to args if one exists.
    @if ($value) {
      $args: list.append($args, $value);
    }

    // Loop through the prop map.
    @each $propKey, $propValue in $prop {

      // Scenario: ("prop": ("prop": "value"))
      @if (meta.type-of($propValue) == "map") {
        @each $key, $value in $propValue {
          // Only call `usage.set` if arguments are passed.
          @if (list.length($args) > 0) {
            @include usage.set($module, "#{$propKey}-#{$key}", $args...);
          }
          $_variables: map.set($_variables, $module, "#{$propKey}-#{$key}", $value) !global;
        }
      }

      // Scenario: ("prop": "value")
      @else {
        // Only call `usage.set` if arguments are passed.
        @if (list.length($args) > 0) {
          @include usage.set($module, $propKey, $args...);
        }
        $_variables: map.set($_variables, $module, $propKey, $propValue) !global;
      }
    }
  }

  // Scenario: "prop", ("prop": "value")
  @else if (meta.type-of($value) == "map") {
    @each $key, $value in $value {
      // Only call `usage.set` if arguments are passed.
      @if (list.length($args) > 0) {
        @include usage.set($module, "#{$prop}-#{$key}", $args...);
      }
      $_variables: map.set($_variables, $module, "#{$prop}-#{$key}", $value) !global;
    }
  }

  // Scenario: "prop", "value"
  @else {
    // Only call `usage.set` if arguments are passed.
    @if (list.length($args) > 0) {
      @include usage.set($module, $prop, $args...);
    }
    $_variables: map.set($_variables, $module, $prop, $value) !global;
  }
}

/// Mixin to remove items from the `$_variables` custom properties map.
/// @param {string} $keys...
///   The list of keys to follow and remove from the custom properties map.
@mixin remove($keys...) {
  @if usage.remove($keys...) {
    $_variables: map.deep-remove($_variables, $keys...) !global;
  }
}

/// Mixin to override a previously defined custom property. This is primarily 
/// used in the context of a modifier. Provided module and property must exist
/// in the `$_variables` custom properties map.
/// @param {string} $module
///   The module name to check the custom property under.
/// @param {string | map} $prop
///   The custom property name to override. Can be a map containing property and 
///   value pairs
/// @param {any} $value [null]
///   The property value to override with.
/// 
/// @example scss
///   @include css.override("core", "background", #000);
/// 
///   // CSS Output
///   --vb-background: #000;
/// 
/// @example scss
///   @include css.override("button", "background", #fff);
/// 
///   // CSS Output
///   --vb-button-background: #fff;
/// 
/// @example scss
///   @include css.override("button", (
///     "background": #000,
///     "foreground": #fff
///   ));
/// 
///   // CSS Output
///   --vb-button-background: #000;
///   --vb-button-foreground: #fff;
///
@mixin override($module, $prop, $value: null) {
  @if _module-exists($module) {
    @if (meta.type-of($prop) == "map") {
      @each $key, $value in $prop {
        @if ($value) {
          @include define($module, $key, $value, "override");
        }
      }
    } @else {
      @if ($value) {
        @include define($module, $prop, $value, "override");
      }
    }
  }
}

/// Output all the stored custom properties of a provided module or of all 
/// modules. Provided module must exist in the `$_variables` map.
/// @param {string} $module ["*"]
///   The module to output all custom properties from. If no module is passed or
///   set to "*" or "all", will output all custom properties for all modules.
/// @param {string} $strategy ["used"]
///   The output strategy to apply. Available options: "*", "all" or "used".
///   - "*" and "all" will output all stored custom properties.
///   - "used" will only output custom properties that have been referenced.
/// 
/// @example scss
///   // Example value in `$_variables` map:
///   $_variables: (
///     "button": (
///       "background": #555,
///       "foreground": #fff,
///       "border": 1px solid #000
///     )
///   );
///   
///   // SCSS input
///   :root {
///     @include css.output("button");
///   }
/// 
///   // CSS output
///   :root {
///     --vb-button-background: #555;
///     --vb-button-foreground: #fff;
///     --vb-button-border: 1px solid #000;
///   }
///
@mixin output($module: "*", $strategy: config.get("output-strategy")) {
  @if ($module == "*") or ($module == "all") {
    // Call output() for every module in $_variables.
    @each $module in map.keys($_variables) {
      @include output($module, $strategy);
    }
  } @else if _module-exists($module, false) {
    $moduleMap: map.get($_variables, $module);
    // Output custom properties via usage output.
    @include usage.output(
      meta.get-mixin("define"), $module, $moduleMap, $strategy
    );
  }
}

/// Log to console either the entire `$_variables` custom properties map, a 
/// module map or module theme. Provided module must exist in the  `$_variables`
/// custom properties map.
/// @param {string} $module ["*"]
///   A module within the custom properties map to log. Leaving as `null` will
///   log the entire map.
@mixin log($module: "*", $props...) {
  @if ($module == "*") or ($module == "all") {
    @include debug-map($_variables, "Custom properties of \"*\"");
  }
  
  @else if _module-exists($module) {
    @if (list.length($props) > 0) {
      @include debug-map(
        map.get($_variables, $module, $props...), 
        "Custom properties of \"#{$module}\" > \"#{$props}\""
      );
    } @else {
      @include debug-map(
        map.get($_variables, $module), 
        "Custom properties of \"#{$module}\""
      );
    }
  }
}
