@use "sass:map";
@use "sass:meta";
@use "sass:list";

@use "./prefix" as prefix;
@use "./variables" as var;

/// Output a CSS variable if a value is provided.
/// @param {String} $name - The name to use in the CSS variable property.
/// @param {All} $value - The value of the CSS variable. Can be any valid CSS property value.
/// @output CSS variable or nothing.
@mixin css($name, $value) {
  @if ($value) {
    --#{prefix.$variable}#{$name}: #{$value};
  }
}

/// Output a dynamic CSS variable using maps and breakpoints.
/// @param {String} $name - The name to use in the CSS variable property.
/// @param {Map | All} $value - The value of the CSS variable or a map of valid variables with breakpoints as the key.
/// @param {Map} $breakpoints - A valid breakpoints map. See: core.$breakpoints.
/// @output A default CSS variable and CSS variables in media queries.
@mixin css-query($name, $value, $breakpoints) {
  // If padding is not a map, set the CSS var.
  @if meta.type-of($value) != 'map' {
    @include css($name, $value);
  }
  // Else padding is a map, loop through the breakpoints and output CSS var.
  @else {
    // Get the first item from breakpoints.
    $_firstKey: list.nth(list.nth($value, 1), 1);
    // Output the fist padding value in the map as the base CSS var.
    @include css($name, map.get($value, $_firstKey));
    // Loop through the breakpoints.
    @each $key, $bpValue in $breakpoints {
      // If key matches padding first key, skip it. We already output it.
      @if $key != $_firstKey {
        // If the breakpoint key exists in the padding map...
        @if map.has-key($value, $key) {
          // Output the media query with new CSS variable value.
          @include media-min($bpValue) {
            @include css($name, map.get($value, $key));
          }
        }
      }
    }
  }
}

/// A media query mixin that defines a query using max-width. You can pass in a
/// key to the `$breakpoints` maps to access that value, or pass a value to
/// create your media query. This mixin will shave a pixel off your breakpoint
/// values so that it never overlaps with a min-width usage.
/// @content Content to output in media query.
/// @param {Number | String} $point
@mixin media-max($point) {
  @if map.has-key(var.$breakpoints, $point) {
    @media (max-width: (map.get(var.$breakpoints, $point) - 1)) {
      @content;
    }
  }
  @else {
    @if (type-of($point) == number) {
      @media (max-width: ($point - 1)) {
        @content;
      }
    }
  }
}

/// A media query mixin that defines a query using min-width. You can pass in a
/// key to the `$breakpoints` map to access that value, or pass a value to
/// create your media query.
/// @content Content to output in media query.
/// @param {Number | String} $point
@mixin media-min($point) {
  @if map.has-key(var.$breakpoints, $point) {
    @media (min-width: map.get(var.$breakpoints, $point)) {
      @content;
    }
  }
  @else {
    @if (type-of($point) == number) {
      @media (min-width: $point) {
        @content;
      }
    }
  }
}

/// Media query mixin can be used for setting styles specifically to retina
/// screens. Used when setting higher resolution background images.
/// @content Content to output in media query.
@mixin media-retina() {
  @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
    @content;
  }
}

/// A gap mixin that creates spacing between an elements children comparable to
/// the gap property for flexbox. Optionally pass a direction string for
/// column-gap ("x") and row-gaps ("y") output.
/// @param {Number} $val - Number unit to apply.
/// @param {String} $dir ["xy"] - Direction to apply flex-gap ("x", "y" or "xy" for both).
/// @param {Boolean} $imp [null] - Whether or not to add `!important` flag.
/// @param {String} $prop ["margin"] - Property to apply gap with ("margin" | "padding").
@mixin flex-gap($val, $dir: "xy", $imp: false, $prop: "margin") {
  @if ($imp) {
    $imp: "!important";
  }
  @else if ($imp == false) {
    $imp: null;
  }

  @if ($dir == "x") {
    margin-left: ($val * -1) #{$imp};

    > * {
      #{$prop}-left: $val #{$imp};
    }
  }
  @else if ($dir == "y") {
    margin-top: ($val * -1) #{$imp};

    > * {
      #{$prop}-top: $val #{$imp};
    }
  }
  @else {
    margin-top: ($val * -1) #{$imp};
    margin-left: ($val * -1) #{$imp};

    > * {
      #{$prop}-top: $val #{$imp};
      #{$prop}-left: $val #{$imp};
    }
  }
}

/// A gap mixin that creates spacing between inline or block level elements.
/// Spacing is added using the `> * + *` selector and can either be applied
/// horizontally or vertically by passing $dir "x" or "y" respectively.
/// @param {Number} $val - Number unit to apply.
/// @param {String} $dir ["y"]- Direction to apply gap ("x", "y").
/// @param {Boolean} $imp [false] - Whether or not to add `!important` flag.
@mixin gap($val, $dir: "y", $imp: false) {
  @if ($imp) {
    $imp: "!important";
  }
  @else if ($imp == false) {
    $imp: null;
  }

  @if ($dir == "x") {
    > * + * {
      margin-left: $val #{$imp};
    }
  }
  @else if ($dir == "y") {
    > * + * {
      margin-top: $val #{$imp};
    }
  }
}

/// A utility mixin for quickly setting the width and height of an element.
/// @param {Number} $width - Width size unit.
/// @param {Number} $height [$width] - Height size unit.
/// @output Width and height properties.
@mixin size($width, $height: $width) {
  width: $width;
  height: $height;
}

/// Add text overflow styles with ellipsis
/// @output Properties for creating ellipsis effect.
@mixin overflow-ellipsis() {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
