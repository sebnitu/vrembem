{
  "version": 3,
  "sources": [
    "../../node_modules/browser-pack-flat/_prelude",
    "../core/index.js",
    "../utility/index.js",
    "index.js"
  ],
  "names": [
    "_$core_1",
    "breakpoints",
    "xs",
    "sm",
    "md",
    "lg",
    "xl",
    "obj",
    "_core",
    "__esModule",
    "default",
    "_defineProperties",
    "target",
    "props",
    "i",
    "length",
    "descriptor",
    "enumerable",
    "configurable",
    "writable",
    "Object",
    "defineProperty",
    "key",
    "_default",
    "instance",
    "Constructor",
    "TypeError",
    "this",
    "staticProps",
    "value",
    "el",
    "c",
    "forEach",
    "toArray",
    "some",
    "has",
    "classList",
    "contains",
    "add",
    "remove",
    "toggle",
    "parentElement",
    "hasClass",
    "item",
    "array",
    "Array",
    "isArray",
    "push",
    "_extend",
    "extend",
    "apply",
    "arguments",
    "toString",
    "extended",
    "deep",
    "prototype",
    "call",
    "merge",
    "prop",
    "hasOwnProperty",
    "_$utility_4",
    "options",
    "settings",
    "switchDrawers",
    "api",
    "defaults",
    "classTarget",
    "classTrigger",
    "classInner",
    "classTargetSwitch",
    "classTriggerSwitch",
    "classInnerSwitch",
    "classActive",
    "classTransitionNone",
    "saveState",
    "switch",
    "switchBreakpoint",
    "transitionDuration",
    "drawers",
    "drawerState",
    "mqlArray",
    "init",
    "_utility",
    "document",
    "querySelectorAll",
    "drawer",
    "defaultState",
    "Promise",
    "resolve",
    "initSaveState",
    "then",
    "initSwitch",
    "addEventListener",
    "trigger",
    "destroy",
    "destroySwitch",
    "stateClear",
    "addClass",
    "removeClass",
    "removeEventListener",
    "open",
    "selector",
    "close",
    "switchToDrawer",
    "items",
    "switchToModal",
    "stateSave",
    "state",
    "callback",
    "toggleClass",
    "event",
    "closest",
    "dataDrawer",
    "dataset",
    "localStorage",
    "getItem",
    "JSON",
    "parse",
    "id",
    "dialog",
    "querySelector",
    "transitionDelay",
    "setTimeout",
    "setItem",
    "stringify",
    "removeItem",
    "cleanSelector",
    "replace",
    "g",
    "toUpperCase",
    "bp",
    "getBreakpoint",
    "mql",
    "window",
    "matchMedia",
    "matches",
    "addListener",
    "switchCheck",
    "removeListener",
    "triggers",
    "className",
    "RegExp",
    "__obj_3"
  ],
  "mappings": "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",
  "sourcesContent": [
    "(function(){\n",
    "export default {\n  \"breakpoints\": {\n    \"xs\": \"480\",\n    \"sm\": \"620\",\n    \"md\": \"760\",\n    \"lg\": \"990\",\n    \"xl\": \"1380\"\n  }\n}\n",
    "import core from \"@vrembem/core\"\n\n/**\n * Utility\n * ---\n * A set of helper methods for general javascript plugin use.\n */\nexport default class {\n\n  /**\n   * Get and output a breakpoint using it\"s key found in core.json\n   * ---\n   * @param {String} key - The key to search for in the breakpoints object\n   * @returns {String} - The pixel value of the breakpoint as a string\n   */\n  static getBreakpoint(key) {\n    return core.breakpoints[key]\n  }\n\n  /**\n   * Checks if an element has a class or not\n   * ---\n   * @param {Node} el - Element(s) to check class(es) on\n   * @param {String || Array} c - Class(es) to check\n   * @returns {Boolean} - Returns true if class exists, otherwise false\n   */\n  static hasClass(el, c) {\n    el = (el.forEach) ? el : this.toArray(el)\n    c = this.toArray(c)\n    return c.some( function (c) {\n      let has = false\n      el.forEach((el) => {\n        if (el.classList.contains(c)) {\n          has = true\n        }\n      })\n      return has\n    })\n  }\n\n  /**\n   * Adds a class or classes to an element\n   * ---\n   * @param {Node} el - Element(s) to add class(es) on\n   * @param {String || Array} c - Class(es) to add\n   */\n  static addClass(el, c) {\n    el = (el.forEach) ? el : this.toArray(el)\n    c = this.toArray(c)\n    el.forEach((el) => {\n      c.forEach((c) => {\n        el.classList.add(c)\n      })\n    })\n  }\n\n  /**\n   * Remove a class or classes from an element\n   * ---\n   * @param {Node} el - Element(s) to remove class(es) from\n   * @param {String || Array} c - Class(es) to remove\n   */\n  static removeClass(el, c) {\n    el = (el.forEach) ? el : this.toArray(el)\n    c = this.toArray(c)\n    el.forEach((el) => {\n      c.forEach((c) => {\n        el.classList.remove(c)\n      })\n    })\n  }\n\n  /**\n   * Toggle a class or classes on an element\n   * ---\n   * @param {Node} el - Element(s) to toggle class(es) on\n   * @param {String || Array} c - Class(es) to toggle\n   */\n  static toggleClass(el, c) {\n    el = (el.forEach) ? el : this.toArray(el)\n    c = this.toArray(c)\n    el.forEach((el) => {\n      c.forEach((c) => {\n        el.classList.toggle(c)\n      })\n    })\n  }\n\n  /**\n   * Find the closest parent element based on class. This is different from the\n   * native .closest() method in that it doesn\"t check the current element.\n   * ---\n   * @param {Node} el - Element to start search on\n   * @param {String || Array} c - Class(es) to check for\n   * @return {Node} - Closest parent element\n   */\n  static closest(el, c) {\n    while ((el = el.parentElement) && !this.hasClass(el, c))\n      return el\n  }\n\n  /**\n   * Converts a string or object to an array. If an array is passed, it\"s\n   * returned as is. Anything else is returned as an array.\n   * ---\n   * @param {Object} item - String or object to convert to an array\n   * @return {Array} - Return the converted array\n   */\n  static toArray(item) {\n\n    let array = []\n\n    if (Array.isArray(item)) {\n      array = item\n    } else {\n      array.push(item)\n    }\n\n    return array\n  }\n\n  /**\n   * Merge two or more objects. Returns a new object. Set the first argument\n   * to `true` for a deep or recursive merge.\n   * ---\n   * @param {Boolean} [Optional] - If true, do a deep (or recursive) merge\n   * @param {Object} - The objects to merge together; each overriding the next\n   * @returns {Object} - Merged values of defaults and options\n   */\n  /* global extend */\n  static extend() {\n\n    let extended = {}\n    let deep = false\n    let i = 0\n    let length = arguments.length\n\n    if ( Object.prototype.toString.call( arguments[0] ) === \"[object Boolean]\" ) {\n      deep = arguments[0]\n      i++\n    }\n\n    let merge = ( obj ) => {\n      for ( let prop in obj ) {\n        if ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {\n          if ( deep && Object.prototype.toString.call(obj[prop]) === \"[object Object]\" ) {\n            extended[prop] = extend( true, extended[prop], obj[prop] )\n          } else {\n            extended[prop] = obj[prop]\n          }\n        }\n      }\n    }\n\n    for ( ; i < length; i++ ) {\n      let obj = arguments[i]\n      merge(obj)\n    }\n\n    return extended\n  }\n\n}\n",
    "import u from \"@vrembem/utility\"\n\n/**\n * Drawer plugin\n * ---\n * A container component that slides in from the left or right. It typically\n * contains menus, search or other content for your app.\n */\nexport default function(options) {\n\n  \"use strict\"\n\n  let api = {}\n  let settings\n\n  const defaults = {\n    // Component element classes\n    classTarget: \"drawer__item\",\n    classTrigger: \"drawer__trigger\",\n    classInner: \"drawer__dialog\",\n\n    // Component element switch classes\n    // Used with RegExp to search and replace element classes\n    classTargetSwitch: \"modal\",\n    classTriggerSwitch: \"modal__trigger\",\n    classInnerSwitch: \"modal__dialog\",\n\n    // State and utility classes\n    classActive: \"is-active\",\n    classTransitionNone: \"transition_none\",\n\n    // Whether or not to store the save state in local storage\n    // {boolean} The string to save our state object as\n    saveState: true,\n\n    // Whether or not to enable the switch functionality. If enabled, a string\n    // selector to check for should be passed.\n    // {false} || {string} e.g. \"[data-drawer-switch]\"\n    switch: \"[data-drawer-switch]\",\n\n    // The default break point for when to switch to drawer or modal classes\n    // {string} Either a breakpoint key or pixel value\n    switchBreakpoint: \"lg\",\n\n    // Duration before removing the transition_none class on initial load\n    transitionDuration: 500\n  }\n\n  // Where we store all our drawers available in the DOM\n  let drawers = []\n\n  // Where we build the save state object before we pass it to local storage\n  let drawerState = {}\n\n  // Where we store all our switch drawers available in the DOM\n  let switchDrawers\n\n  // Where we store all our media query lists along with their drawers\n  let mqlArray = []\n\n  /**\n   * The constructor method, run as soon as an instance is created\n   * ---\n   * @param {Object} options - A json object with your custom settings\n   */\n  api.init = (options) => {\n\n    // Merge the defaults and passed options into our settings obj\n    settings = u.extend( defaults, options || {} )\n\n    // Get all the drawers on the page and save them with their default state\n    document.querySelectorAll(\".\" + settings.classTarget)\n      .forEach((drawer) => {\n      drawers.push({\n        \"drawer\": drawer,\n        \"defaultState\": u.hasClass(drawer, settings.classActive)\n      })\n    })\n\n    // Initialize a promise and init save state if it's enabled\n    let promiseSaveState = new Promise((resolve) => {\n      if (settings.saveState) {\n        initSaveState(resolve)\n      } else {\n        resolve()\n      }\n    })\n\n    // After promise is resolved and switch is enabled, initialize switch\n    promiseSaveState.then(() => {\n      if (settings.switch) {\n        initSwitch()\n      }\n    })\n\n    // Add our drawer trigger event listener\n    document.addEventListener(\"click\", trigger, false)\n  }\n\n  /**\n   * The deconstructor method, used to reset and destroy the drawer instance\n   * ---\n   * @param {Boolean} defaultState - Return drawers to their default state?\n   */\n  api.destroy = (defaultState = true) => {\n\n    // Destroy our switch\n    destroySwitch()\n\n    // Destroy our state\n    stateClear()\n\n    // Return drawrs to their default state\n    if (defaultState) {\n      drawers.forEach((item) => {\n        if (item.defaultState) {\n          u.addClass(item.drawer, settings.classActive)\n        } else {\n          u.removeClass(item.drawer, settings.classActive)\n        }\n      })\n    }\n\n    // Clear our variables\n    settings = null\n    drawers = []\n\n    // Remove the drawer trigger event listener\n    document.removeEventListener(\"click\", trigger, false)\n  }\n\n  /**\n   * Public method to open a drawer or group of drawers\n   * ---\n   * @param {String} selector - A valid CSS selector\n   */\n  api.open = (selector) => {\n    selector = (selector) ? selector : \".\" + settings.classTarget\n    toggle(document.querySelectorAll(selector), \"open\")\n  }\n\n  /**\n   * Public method to close a drawer or group of drawers\n   * ---\n   * @param {String} selector - A valid CSS selector\n   */\n  api.close = (selector) => {\n    selector = (selector) ? selector : \".\" + settings.classTarget\n    toggle(document.querySelectorAll(selector), \"close\")\n  }\n\n  /**\n   * Public method to toggle a drawer or group of drawers\n   * ---\n   * @param {String} selector - A valid CSS selector\n   */\n  api.toggle = (selector) => {\n    selector = (selector) ? selector : \".\" + settings.classTarget\n    toggle(document.querySelectorAll(selector))\n  }\n\n  /**\n   * Public method to switch a modal into drawer\n   * ---\n   * @param {String} selector - A valid CSS selector\n   */\n  api.switchToDrawer = (selector) => {\n\n    // Use default selector if one isn't passed\n    selector = (selector) ? selector : settings.switch\n\n    // Query our elements using the provided selector\n    let items = document.querySelectorAll(selector)\n\n    // Convert to array if only one drawer is passed\n    items = (items.forEach) ? items : u.toArray(items)\n\n    items.forEach((item) => {\n      switchToDrawer(item)\n    })\n  }\n\n  /**\n   * Public method to switch a drawer into modal\n   * ---\n   * @param {String} selector - A valid CSS selector\n   */\n  api.switchToModal = (selector) => {\n\n    // Use default selector if one isn't passed\n    selector = (selector) ? selector : settings.switch\n\n    // Query our elements using the provided selector\n    let items = document.querySelectorAll(selector)\n\n    // Convert to array if only one drawer is passed\n    items = (items.forEach) ? items : u.toArray(items)\n\n    items.forEach((item) => {\n      switchToModal(item)\n    })\n  }\n\n  /**\n   * Save the drawer current drawer state\n   */\n  api.stateSave = () => {\n    stateSave()\n  }\n\n  /**\n   * Clears drawer state from local storage\n   */\n  api.stateClear = () => {\n    stateClear()\n  }\n\n  /**\n   * Private function to close a drawer or group of drawers\n   * ---\n   * @param {Node} drawer - The drawer element(s) to close\n   * @param {String} state - Whether to open, close or toggle the drawer(s)\n   * @param {Function} callback - The callback function\n   */\n  const toggle = (drawer, state, callback) => {\n\n    // Check if drawer(s) should be opened, closed or toggled and either add or\n    // remove the active class to the passed drawer(s)\n    if (state === \"open\") {\n      u.addClass(drawer, settings.classActive)\n    } else if (state === \"close\") {\n      u.removeClass(drawer, settings.classActive)\n    } else {\n      u.toggleClass(drawer, settings.classActive)\n    }\n\n    // Save state if feature is enabled\n    if (settings.saveState) {\n      stateSave(drawer)\n    }\n\n    // Fire the callback function if one was passed\n    typeof callback === \"function\" && callback()\n  }\n\n  /**\n   * Private function to toggle drawer via a trigger\n   */\n  const trigger = () => {\n\n    // Get the closest trigger element from the click event\n    let trigger = event.target.closest(\".\" + settings.classTrigger)\n\n    // Check that the class trigger was clicked\n    if (trigger) {\n\n      // Get the drawer selector from the trigger via [data-target]\n      let dataDrawer = trigger.dataset.target\n\n      // Check that a drawer target was given\n      if (dataDrawer) {\n\n        // Query the drawer element and toggle it if it exists\n        let drawer = document.querySelectorAll(dataDrawer)\n        if (drawer.length) {\n          toggle(drawer)\n        }\n      }\n    }\n  }\n\n  /**\n   * Private function that initializes the save state functionality\n   * ---\n   * @param {Function} callback - The callback function\n   */\n  const initSaveState = (callback) => {\n\n    // Check if a drawer state is already saved in local storage and save the\n    // json parsed data to our local variable if it does\n    if (localStorage.getItem(\"drawerState\")) {\n      drawerState = JSON.parse(localStorage.getItem(\"drawerState\"))\n    }\n\n    // Loop through all drawers\n    drawers.forEach((item) => {\n\n      let drawer = item.drawer\n\n      // Set the default state if one is not set\n      if (drawer.id in drawerState === false) {\n        stateSave(drawer)\n      }\n\n      // Get our drawer dialog element\n      let dialog = drawer.querySelector(\".\" + settings.classInner)\n\n      // Disables transitions as default states are being set\n      let transitionDelay = () => {\n        if (dialog) {\n          u.addClass(dialog, settings.classTransitionNone)\n          setTimeout(() => {\n            u.removeClass(dialog, settings.classTransitionNone)\n          }, settings.transitionDuration)\n        }\n      }\n\n      // Toggle our drawer state based on the saved state\n      if (drawerState[drawer.id] === false) {\n        toggle(drawer, \"close\", transitionDelay)\n      } else if (drawerState[drawer.id]) {\n        toggle(drawer, \"open\", transitionDelay)\n      }\n    })\n\n    // Fire the callback function if one was passed and return our state object\n    typeof callback === \"function\" && callback(drawerState)\n  }\n\n  /**\n   * Private function that saves the state of a specific or all drawers\n   * ---\n   * @param {Node} items - The drawer element(s) to save state\n   */\n  const stateSave = (items) => {\n\n    // Save all drawers if an items arg wasn't passed\n    items = (items) ? items : drawers\n\n    // Convert to array if only one drawer is passed\n    items = (items.forEach) ? items : u.toArray(items)\n\n    // Loop through our drawers and save their new state to local storage\n    items.forEach((item) => {\n\n      if (item.drawer) {\n        item = item.drawer\n      }\n\n      // Only save drawer state if an id exists\n      if (item.id) {\n        drawerState[item.id] = u.hasClass(item, settings.classActive)\n        localStorage.setItem(\"drawerState\", JSON.stringify(drawerState))\n      }\n    })\n  }\n\n  /**\n   * Private function that clears the drawer state\n   */\n  const stateClear = () => {\n    drawerState = {}\n    localStorage.removeItem(\"drawerState\")\n  }\n\n  /**\n   * Private function that initializes the switch functionality\n   */\n  const initSwitch = () => {\n\n    // Query all the drawers with the switch feature enabled\n    switchDrawers = document.querySelectorAll(settings.switch)\n\n    // Loop through the switch drawers\n    switchDrawers.forEach((drawer) => {\n\n      // Get the local breakpoint if one is set\n      // Remove brackets and the intial data flag\n      let cleanSelector = settings.switch\n        .replace(\"[\", \"\")\n        .replace(\"]\", \"\")\n        .replace(\"data-\", \"\")\n\n      // Convert sring to camelCase\n      cleanSelector = cleanSelector.replace(/-([a-z])/g, (g) => {\n        return g[1].toUpperCase()\n      })\n\n      // Check which breakpoint to use:\n      // a) The local bp set on the drawer\n      // b) The bp available in config using a key\n      // c) The raw pixel value provided in settings\n      let bp = drawer.dataset[cleanSelector]\n      if (bp) {\n        bp = u.getBreakpoint(bp)\n        if (!bp) {\n          bp = drawer.dataset[cleanSelector]\n        }\n      } else {\n        bp = u.getBreakpoint(settings.switchBreakpoint)\n        if (!bp) {\n          bp = settings.switchBreakpoint\n        }\n      }\n\n      // Media query listener\n      let mql = window.matchMedia( \"(min-width:\" + bp + \")\" )\n\n      // Switch to modal if media doesn't match (< bp)\n      if (!mql.matches) {\n        switchToModal(drawer)\n      }\n\n      // Add our media query listener\n      mql.addListener(switchCheck)\n\n      // Push the mql to our array along with it's drawer\n      mqlArray.push({\n        \"drawer\" : drawer,\n        \"mql\": mql\n      })\n    })\n  }\n\n  /**\n   * Private function that destroys the switch functionality\n   */\n  const destroySwitch = () => {\n\n    // Switch all modals back to their original drawer state\n    switchDrawers.forEach((drawer) => {\n      switchToDrawer(drawer)\n    })\n\n    // Remove the media query listeners\n    mqlArray.forEach((item) => {\n      item.mql.removeListener(switchCheck)\n    })\n\n    // Return switch variables to their original state\n    switchDrawers = null\n    mqlArray = []\n  }\n\n  /**\n   * Private function that checks when a media query hits a match and switches\n   * the component from drawer to modal as needed\n   * ---\n   * @param {MediaQueryList} mql - The MediaQueryList object for the media query\n   * @param {Node} drawer - The drawer element to switch\n   */\n  const switchCheck = () => {\n    mqlArray.forEach((item) => {\n      if (item.mql.matches) {\n        switchToDrawer(item.drawer)\n      } else {\n        switchToModal(item.drawer)\n      }\n    })\n  }\n\n  /**\n   * Private function that switches a modal into a drawer component\n   * ---\n   * @param {Node} drawer - The element to switch\n   */\n  const switchToDrawer = (drawer) => {\n\n    // Get the dialog and trigger elements related to this component\n    let dialog = drawer.querySelector(\".dialog\")\n    let triggers = document.querySelectorAll(\"[data-target=\\\"#\" + drawer.id + \"\\\"]\")\n\n    // Switch the modal component to drawer\n    drawer.className = drawer.className.replace(\n      new RegExp(settings.classTargetSwitch, \"gi\"),\n      settings.classTarget\n    )\n    dialog.className = dialog.className.replace(\n      new RegExp(settings.classInnerSwitch, \"gi\"),\n      settings.classInner\n    )\n    triggers.forEach((trigger) => {\n      trigger.className = trigger.className.replace(\n        new RegExp(settings.classTriggerSwitch, \"gi\"),\n        settings.classTrigger\n      )\n    })\n\n    // Open or close drawer based on save state\n    if (settings.saveState) {\n      if (drawerState[drawer.id] === false) {\n        toggle(drawer, \"close\")\n      } else {\n        toggle(drawer, \"open\")\n      }\n    }\n  }\n\n  /**\n   * Private function that switches a drawer into a modal component\n   * ---\n   * @param {Node} drawer - The element to switch\n   */\n  const switchToModal = (drawer) => {\n\n    // Get the dialog and trigger elements related to this component\n    let dialog = drawer.querySelector(\".dialog\")\n    let triggers = document.querySelectorAll(\"[data-target=\\\"#\" + drawer.id + \"\\\"]\")\n\n    // Switch the drawer component to modal\n    drawer.className = drawer.className.replace(\n      new RegExp(settings.classTarget, \"gi\"),\n      settings.classTargetSwitch\n    )\n    dialog.className = dialog.className.replace(\n      new RegExp(settings.classInner, \"gi\"),\n      settings.classInnerSwitch\n    )\n    triggers.forEach((trigger) => {\n      trigger.className = trigger.className.replace(\n        new RegExp(settings.classTrigger, \"gi\"),\n        settings.classTriggerSwitch\n      )\n    })\n\n    // Remove active class for modal styles by default\n    u.removeClass(drawer, settings.classActive)\n  }\n\n  /**\n   * Initialize our component and return the api\n   */\n  api.init(options)\n  return api\n}\n"
  ],
  "sourceRoot": ""
}