---
title: Collections
description: "Collection and CollectionEntry are base classes designed to manage component instances and implement shared systems."
parent: core
group: collections
---

Collections are used to create the scaffolding and shared systems that all Vrembem JavaScript components inherit. These systems include configuration, events, lifecycle hooks, and plugins.

<CodeExample lang="js">
```js
import { Collection, CollectionEntry } from "@vrembem/core";
```
</CodeExample>

## Example usage

The best way to understand collections and the systems they offer is to create a component and use them directly. In this documentation, we'll create an example component and explore the collections API in practice.

In this example component, we will cover the following concepts:

- Instantiating and configuring a custom Collection and CollectionEntry.
- Managing a group of related elements as a collection.
- Emitting and listening for custom events between entries and the collection.
- Implementing lifecycle hooks such as `onCreateEntry`, `onRegisterEntry`, `beforeMount`, `afterMount`, etc.
- Querying and updating the collection using the `Collection.get` method.
- Demonstrating separation of concerns between collection and entry logic.

This example provides a practical, end-to-end demonstration of how to use the Collections API to build interactive, stateful UI components.

### Markup and styles

While the main focus of this example is the Collections API, it's important to start with solid markup and styles as a foundation. For a tic-tac-toe game, we'll want to define the "board" using a table element. We'll also add a title and reset button later that we can integrate into our collection's state.

<CodeExample tabs>
<div slot="output" class="tictactoe-wrapper">
  <table class="tictactoe">
    <tr>
      <td id="cell-A1" class="tictactoe__cell" data-cell="A1" role="button" tabindex="0"></td>
      <td id="cell-B1" class="tictactoe__cell" data-cell="B1" role="button" tabindex="0"></td>
      <td id="cell-C1" class="tictactoe__cell" data-cell="C1" role="button" tabindex="0"></td>
    </tr>
    <tr>
      <td id="cell-A2" class="tictactoe__cell" data-cell="A2" role="button" tabindex="0"></td>
      <td id="cell-B2" class="tictactoe__cell" data-cell="B2" role="button" tabindex="0"></td>
      <td id="cell-C2" class="tictactoe__cell" data-cell="C2" role="button" tabindex="0"></td>
    </tr>
    <tr>
      <td id="cell-A3" class="tictactoe__cell" data-cell="A3" role="button" tabindex="0"></td>
      <td id="cell-B3" class="tictactoe__cell" data-cell="B3" role="button" tabindex="0"></td>
      <td id="cell-C3" class="tictactoe__cell" data-cell="C3" role="button" tabindex="0"></td>
    </tr>
  </table>
</div>
<Fragment slot="tab-html">
```html
<table class="tictactoe">
  <tr>
    <td id="cell-A1" class="tictactoe__cell" data-cell="A1" role="button" tabindex="0"></td>
    <td id="cell-B1" class="tictactoe__cell" data-cell="B1" role="button" tabindex="0"></td>
    <td id="cell-C1" class="tictactoe__cell" data-cell="C1" role="button" tabindex="0"></td>
  </tr>
  <tr>
    <td id="cell-A2" class="tictactoe__cell" data-cell="A2" role="button" tabindex="0"></td>
    <td id="cell-B2" class="tictactoe__cell" data-cell="B2" role="button" tabindex="0"></td>
    <td id="cell-C2" class="tictactoe__cell" data-cell="C2" role="button" tabindex="0"></td>
  </tr>
  <tr>
    <td id="cell-A3" class="tictactoe__cell" data-cell="A3" role="button" tabindex="0"></td>
    <td id="cell-B3" class="tictactoe__cell" data-cell="B3" role="button" tabindex="0"></td>
    <td id="cell-C3" class="tictactoe__cell" data-cell="C3" role="button" tabindex="0"></td>
  </tr>
</table>
```
</Fragment>
<Fragment slot="tab-css">
```css
.tictactoe__cell {
  --ttt-border: 0.25em solid var(--vb-neutral-95);
  width: 3em;
  height: 3em;
  font-size: 1.6em;
  text-align: center;
  cursor: pointer;
  box-shadow: inset 0 0 0 0.25em white;

  &.is-winner {
    background-color: var(--vb-primary-90);
    color: var(--vb-primary-20);
  }

  &:first-child {
    border-right: var(--ttt-border);
  }

  &:last-child {
    border-left: var(--ttt-border);
  }

  tr:first-child & {
    border-bottom: var(--ttt-border);
  }

  tr:last-child & {
    border-top: var(--ttt-border);
  }
}
```
</Fragment>
</CodeExample>

Each collection entry must have a unique ID to ensure it can be referenced and managed correctly within the collection. For this example, the collection will consist of the table cells that make up the tic-tac-toe board.

### Creating a collection

In our JavaScript we can import `Collection` and define a `TicTacToe` class which extends Collection. Next, we'll instantiate the collection and provide a selector option, which determines which elements are included in the collection. Finally the collection is populated using the `mount` method.

<CodeExample lang="js">
```js
// Import Collection from core
import { Collection } from "@vrembem/core";

// Define our custom collection class
class TicTacToe extends Collection {
  constructor(options) {
    super(options);
  }
}

// Instantiate the collection and provide a collection selector
const ticTacToe = new TicTacToe({
  selector: ".tictactoe__cell"
});

// Mount the collection
await ticTacToe.mount();
```
</CodeExample>

By default, each entry in a collection is an instance of the `CollectionEntry` class. For simple use cases, this is often sufficient. However, if your entries need custom logic or state, you can create your own entry class by extending `CollectionEntry` and assigning it to the `entryClass` property of your collection.

<CodeExample lang="js">
```js
// Import CollectionEntry from core
import { Collection, CollectionEntry } from "@vrembem/core";

// Define a custom collection entry class
class TicTacToeCell extends CollectionEntry {
  constructor(...args) {
    super(...args);
  }
}

class TicTacToe extends Collection {
  constructor(options) {
    super(options);
    // Assign our custom entry class to the `entryClass` property
    this.entryClass = TicTacToeCell;
  }
}
```
</CodeExample>

### Lifecycle hooks

Lifecycle hooks are special methods in `Collection` and `CollectionEntry` that are automatically called at specific points during its existenceâ€”such as mount, creation, or registration. They allow you to run custom logic in response to these events, making it easier to manage state, resources, and side effects.

All hooks are run in the context of the collection, but only create and register hooks are run in the context of entries.

Lifecycle hooks that are run when `mount` is called:

- `beforeMount`
- `onCreateEntry`
- `onRegisterEntry`
- `afterMount`

Lifecycle hooks that are run when `unmount` is called:

- `beforeUnmount`
- `onDestroyEntry`
- `onDeregisterEntry`
- `afterUnmount`
