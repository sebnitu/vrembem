---
import OnThisPageList from "./OnThisPageList.astro";

const { headings, menuClass } = Astro.props;

// Filter the headings to only display the ones we want.
const otp = build(headings.filter((item) => item.depth === 2));

function build(headings) {
  const otp = [];
  const parentHeadings = new Map();
  headings.forEach((h) => {
    const heading = { ...h, subheadings: [] };
    parentHeadings.set(heading.depth, heading);
    // Change depth to 1 if your markdown includes your <h1>, else set to 2.
    const depth = 2;
    if (heading.depth === depth) {
      otp.push(heading);
    } else {
      parentHeadings.get(heading.depth - 1).subheadings.push(heading);
    }
  });
  return otp;
}
---

<nav>
  { 
    !!otp.length && (
      <h2 class="padding padding-y-sm">On this page</h2>
      <ul class={`menu menu_otp${menuClass ? " " + menuClass : ""}`}>
        {otp.map((item) => <OnThisPageList {item} />)}
        <li class="menu__sep display-none" data-scroll-config="{ 'value': 200, 'toggle': 'display-none' }"></li>
        <li class="menu__item display-none" data-scroll-config="{ 'value': 200, 'toggle': 'display-none' }">
          <a href="#main" class="menu__action">Back to top</a>
        </li>
      </ul>
    )
  }
</nav>

<script>
// Import and mount scroll spy module.
import { scrollSpy } from '../modules/scrollSpy';
const spy = scrollSpy().mount();
window['scrollSpy'] = spy;

// Setup the initial OnThisPage (otp) collection array.
const otp = [];

// Set the array of all menu action elements.
const menuActions = Array.prototype.slice.call(document.querySelectorAll('.menu_otp .menu__action'));

// Build the otp collection by looping through menu actions.
menuActions.forEach((menuAction) => {
  // Get the heading using the menu action's href.
  const href = menuAction.getAttribute('href');
  const heading = document.querySelector(`.layout__content ${href}`);

  // Guard if there is no heading returned.
  if (!heading) return;

  // Build the entry object.
  const entry = {
    menuAction: menuAction,
    heading: heading,
    get active() {
      return this.menuAction.classList.contains('is-active');
    },
    set active(value) {
      this.menuAction.classList.toggle('is-active', value);
    },
    get top() {
      const rect = heading.getBoundingClientRect();
      const margin = parseFloat(getComputedStyle(heading).scrollMarginTop);
      return Math.round(rect.top - margin);
    }
  }

  // Push entry into otp array.
  otp.push(entry);
});

function setActive(entries) {
  // Filter out entries that have a positive top value.
  const pos = otp.filter((entry) => entry.top <= 0);
  // Find the entry with a negative top value that is closest to zero.
  const min = Math.max(...pos.map(entry => entry.top))
  const result = otp.filter(entry => entry.top === min)

  // Set the active state of entries by comparing them with the result.
  entries.forEach((entry) => {
    entry.active = (entry === result[0]);
  });
}

// Setup the scroll event.
window.addEventListener('scroll', () => {
  setActive(otp);
});

</script>
