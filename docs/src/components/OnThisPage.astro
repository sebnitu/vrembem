---
import OnThisPageList from "./OnThisPageList.astro";

const { headings, menuClass } = Astro.props;

// Filter the headings to only display the ones we want.
const otp = build(headings.filter((item) => item.depth === 2));

function build(headings) {
  const otp = [];
  const parentHeadings = new Map();
  headings.forEach((h) => {
    const heading = { ...h, subheadings: [] };
    parentHeadings.set(heading.depth, heading);
    // Change depth to 1 if your markdown includes your <h1>, else set to 2.
    const depth = 2;
    if (heading.depth === depth) {
      otp.push(heading);
    } else {
      parentHeadings.get(heading.depth - 1).subheadings.push(heading);
    }
  });
  return otp;
}
---

<nav>
  { 
    !!otp.length && (
      <h2 class="padding padding-y-sm">On this page</h2>
      <ul class={`menu menu_otp${menuClass ? " " + menuClass : ""}`}>
        {otp.map((item) => <OnThisPageList {item} />)}
      </ul>
    )
  }
</nav>

<script>
// Get an array of all menu action items.
const items = Array.prototype.slice.call(document.querySelectorAll('.menu_otp .menu__action'));

// Setup observer instance.
const observer = new IntersectionObserver(observerCallback, {
  rootMargin: '-10% 0% -90% 0%'
});

// Track all headings that have a menu_otp action link.
items.forEach((item) => {
  const href = item.getAttribute('href');
  const heading = document.querySelector(href);
  if (heading) {
    observer.observe(heading);
  }
});

function observerCallback(entries) {
  // If there are many entries...
  if (entries.length > 1) {
    // Get the last observe entry that is above the root bounds.
    const entry = entries.findLast((entry) => {
      return !(entry.boundingClientRect.top > entry.rootBounds.top);
    });

    // If an entry was returned, set it's link element as active and return.
    if (entry) {
      // Remove all active states.
      items.forEach((item) => {
        item.classList.remove('is-active');
      });

      // Add the active state.
      const id = entry.target.getAttribute('id');
      const el = document.querySelector(`.menu_otp a[href="#${id}"]`);
      el.classList.add('is-active');
    }
    return;
  }

  // If there is only one entry...
  entries.forEach(entry => {
    // If observe entry is below the root bounds
    if (entry.boundingClientRect.top > entry.rootBounds.top) {
      // Get the index (-1) of the current active element.
      const index = items.findIndex((item) => {
        return item.classList.contains('is-active');
      }) - 1;

      // Remove all active states.
      items.forEach((item) => {
        item.classList.remove('is-active');
      });

      // Apply active state to the previous element.
      if (index >= 0) {
        items[index].classList.add('is-active');
      }
    }
    
    // If observe entry is above the root bounds.
    else {
      // Remove all active states.
      items.forEach((item) => {
        item.classList.remove('is-active');
      });

      // Add the active state.
      const id = entry.target.getAttribute('id');
      const el = document.querySelector(`.menu_otp a[href="#${id}"]`);
      el.classList.add('is-active');
    }
  });
}

</script>
